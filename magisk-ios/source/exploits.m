//
//  exploits.c
//  Undecimus
//
//  Created by Pwn20wnd on 7/10/19.
//  Copyright Â© 2019 Pwn20wnd. All rights reserved.
//

#include "exploits.h"
#include <common.h>
#include "utils.h"
#include <sys/sysctl.h>

#define REQ_NO_SMAP (1<<0)
#define REQ_NO_PAC (1<<1)
#define REQ_4K_PAGESIZE (1<<2)
#define REQ_16K_PAGESIZE (1<<3)
#define REQ_PAC_BYPASS (1<<4)
#define REQ_PAC (1<<5)

#define IS_4K_PAGESIZE (get_kernel_page_size() == 0x1000)
#define IS_16K_PAGESIZE (get_kernel_page_size() == 0x4000)
#define IS_NO_SMAP (get_kernel_page_size() == 0x1000 || machineNameContains("iPad5,") || machineNameContains("iPhone8,") || machineNameContains("iPad6,"))
#define IS_NO_PAC (get_cpu_subtype() != CPU_SUBTYPE_ARM64E)
#define HAS_PAC_BYPASS (evaluate_exploit_by_name(K_VOUCHER_SWAP))

exploit_t *exploits[] = {
    &(exploit_t)
    {
        .name = K_ASYNC_WAKE,
        .reliability = 95.00,
        .min_kernel_version = "4397.0.0.2.4~1",
        .max_kernel_version = "4570.20.62~4",
        .exception_handler = NULL,
        .requirements = 0,
        .exploit_support = EXPLOIT_SUPPORT_JAILBREAK,
    },
    &(exploit_t)
    {
        .name = K_VOUCHER_SWAP,
        .reliability = 90.00,
        .min_kernel_version = "4397.0.0.2.4~1",
        .max_kernel_version = "4903.240.8~8",
        .exception_handler = ^(int *exception) {
            if (kCFCoreFoundationVersionNumber >= kCFCoreFoundationVersionNumber_iOS_12_0) {
                if (machineNameContains("iPad5,")) {
                    *exception = EXC_FAILURE;
                    return;
                }
            }
            *exception = EXC_NONE;
        },
        .requirements = REQ_16K_PAGESIZE,
        .exploit_support = EXPLOIT_SUPPORT_JAILBREAK | EXPLOIT_SUPPORT_PANIC,
    },
    &(exploit_t)
    {
        .name = K_SOCKPUPPET,
        .reliability = 95.00,
        .min_kernel_version = "4397.0.0.2.4~1",
        .max_kernel_version = "4903.260.65.100.1~2",
        .exception_handler = ^(int *exception) {
            if (kCFCoreFoundationVersionNumber == kCFCoreFoundationVersionNumber_iOS_12_4) {
                *exception = EXC_PASS;
                return;
            }
            *exception = EXC_NONE;
        },
        .requirements = 0,
        .exploit_support = EXPLOIT_SUPPORT_JAILBREAK,
    },
    &(exploit_t)
    {
        .name = K_TIME_WASTE,
        .reliability = 99.00,
        .min_kernel_version = "6110.0.0.120.8~3",
        .max_kernel_version = "6153.60.66~39",
        .exception_handler = NULL,
        .requirements = 0,
        .exploit_support = EXPLOIT_SUPPORT_JAILBREAK,
    },
    &(exploit_t)
    {
        .name = K_SOCKPORT,
        .reliability = 80.0,
        .min_kernel_version = "4397.0.0.2.4~1",
        .max_kernel_version = "4903.260.65.100.1~2",
        .exception_handler = ^(int *exception) {
            if (kCFCoreFoundationVersionNumber == kCFCoreFoundationVersionNumber_iOS_12_4) {
                *exception = EXC_PASS;
                return;
            }
            *exception = EXC_NONE;
        },
        .requirements = REQ_NO_SMAP,
        .exploit_support = EXPLOIT_SUPPORT_JAILBREAK,
    },
#if __arm64e__
    &(exploit_t)
    {
        .name = K_ZECOPS_PAC,
        .reliability = 90.0,
        .min_kernel_version = "4903.272.1~1",
        .max_kernel_version = "4903.272.1~1",
        .exception_handler = NULL,
        .requirements = 0,
        .exploit_support = EXPLOIT_SUPPORT_JAILBREAK,
    },
#endif
    &(exploit_t)
    {
        .name = K_MACH_SWAP,
        .reliability = 85.00,
        .min_kernel_version = "4397.0.0.2.4~1",
        .max_kernel_version = "4903.240.8~8",
        .exception_handler = NULL,
        .requirements = REQ_NO_SMAP | REQ_NO_PAC,
        .exploit_support = EXPLOIT_SUPPORT_JAILBREAK,
    },
    &(exploit_t)
    {
        .name = K_MACH_SWAP_2,
        .reliability = 80.00,
        .min_kernel_version = "4397.0.0.2.4~1",
        .max_kernel_version = "4903.240.8~8",
        .exception_handler = NULL,
        .exploit_support = EXPLOIT_SUPPORT_JAILBREAK,
    },
    &(exploit_t)
    {
        .name = K_DEJA_XNU,
        .reliability = 90.00,
        .min_kernel_version = "4397.0.0.2.4~1",
        .max_kernel_version = "4570.70.24~9",
        .exception_handler = NULL,
        .exploit_support = EXPLOIT_SUPPORT_RESPRING,
    },
    &(exploit_t)
    {
        .name = K_NECP,
        .reliability = 95.00,
        .min_kernel_version = "4397.0.0.2.4~1",
        .max_kernel_version = "4570.70.24~9",
        .exception_handler = NULL,
        .exploit_support = EXPLOIT_SUPPORT_PANIC,
    },
    &(exploit_t)
    {
        .name = K_KALLOC_CRASH,
        .reliability = 90.00,
        .min_kernel_version = "4397.0.0.2.4~1",
        .max_kernel_version = "4903.252.2~2",
        .exception_handler = NULL,
        .exploit_support = EXPLOIT_SUPPORT_PANIC,
    },
    NULL
};

void iterate_exploits(void (^handler)(exploit_t *exploit)) {
    init_function();
    assert(handler != NULL);
    for (exploit_t **exploit = exploits; *exploit; exploit++) {
        handler(*exploit);
    }
}

void iterate_evaluated_exploits(void (^handler)(exploit_t *exploit)) {
    init_function();
    assert(handler != NULL);
    iterate_exploits(^(exploit_t *exploit) {
        if (!evaluate_exploit(exploit)) {
            return;
        }
        handler(exploit);
    });
}

exploit_t *get_exploit_by_name(const char *name) {
    init_function();
    if (name == NULL) return NULL;
    __block exploit_t *found_exploit = NULL;
    iterate_exploits(^(exploit_t *exploit) {
        if (strcmp(exploit->name, name) == 0) {
            found_exploit = exploit;
        }
    });
    return found_exploit;
}

bool evaluate_exploit(exploit_t *exploit) {
    init_function();
    bool ret = false;
    NSString *kernelBuildVersion = nil;
    char *machineName = NULL;
    int exception = EXC_NONE;
    if (exploit == NULL) goto out;
    kernelBuildVersion = getKernelBuildVersion();
    if (kernelBuildVersion == nil) goto out;
    machineName = getMachineName();
    if (machineName == NULL) goto out;
    if (exploit->exception_handler != NULL) {
        exploit->exception_handler(&exception);
        if (exception == EXC_PASS) {
            ret = true;
            goto out;
        } else if (exception == EXC_FAILURE) {
            goto out;
        }
    }
    if (exploit->requirements & REQ_4K_PAGESIZE && !IS_4K_PAGESIZE) goto out;
    if (exploit->requirements & REQ_16K_PAGESIZE && !IS_16K_PAGESIZE) goto out;
    if (exploit->requirements & REQ_NO_SMAP && !IS_NO_SMAP) goto out;
    if (exploit->requirements & REQ_NO_PAC && !IS_NO_PAC) goto out;
	if (exploit->requirements & REQ_PAC && IS_NO_PAC) goto out;
    if (exploit->requirements & REQ_PAC_BYPASS && !IS_NO_PAC && !HAS_PAC_BYPASS) goto out;
    if ([kernelBuildVersion compare:@(exploit->min_kernel_version) options:NSNumericSearch] == NSOrderedAscending) goto out;
    if ([kernelBuildVersion compare:@(exploit->max_kernel_version) options:NSNumericSearch] == NSOrderedDescending) goto out;
    ret = true;
out:;
    SafeFreeNULL(machineName);
    return ret;
}

bool evaluate_exploit_by_name(const char *name) {
    init_function();
    exploit_t *exploit = get_exploit_by_name(name);
    return evaluate_exploit(exploit);
}

exploit_t *get_best_exploit(int support) {
    init_function();
    __block exploit_t *best_exploit = NULL;
    iterate_evaluated_exploits(^(exploit_t *exploit) {
        if (!(exploit->exploit_support & support)) {
            return;
        }
        if (best_exploit == NULL || exploit->reliability > best_exploit->reliability) {
            best_exploit = exploit;
        }
    });
    return best_exploit;
}

const char *get_best_exploit_by_name(int support) {
    init_function();
    exploit_t *exploit = get_best_exploit(support);
    return exploit != NULL ? exploit->name : NULL;
}

bool has_exploit_support(int support) {
    init_function();
    __block bool supported = false;
    iterate_evaluated_exploits(^(exploit_t *exploit) {
        if (!(exploit->exploit_support & support)) return;
        supported = true;
    });
    return supported;
}
